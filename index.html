<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PIOSI - Modular Game with Accurate Enemy Pathing</title>
    <!-- Load the extra light (200) version of the Sono font from Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Sono:wght@200&display=swap"
      rel="stylesheet"
    />
    <style>
      html {
        font-size: 14px;
      }
      body {
        font-family: 'Sono', monospace;
        font-size: 1rem;
        text-align: center;
        background-color: #222;
        color: white;
        margin: 0;
        padding: 0;
      }
      #title-screen {
        position: relative;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        overflow: hidden;
      }
      #title-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('IMG_0905.JPG') no-repeat center center;
        background-size: cover;
        filter: blur(20px);
        opacity: 0.7;
        z-index: -1;
      }
      .image-container {
        width: 80%;
        height: 80%;
        max-width: 80vh;
        max-height: 80vw;
        background: url('IMG_0905.JPG') no-repeat center center;
        background-size: contain;
        z-index: 1;
      }
      .image-container::before {
        content: '';
        position: absolute;
        top: -20%;
        left: -20%;
        width: 140%;
        height: 140%;
        background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAAAAAsNcNlwAAAAkUlEQVR42mNkgIH/j4wMDAwMDAY0wAGGfgYWFgYGBgYGNpgIMEAoggMDwMDAwMDAwMAAALsc9j1vXLaAAAAAAElFTkSuQmCC') repeat;
        opacity: 0.1;
        animation: static-noise 10s linear infinite;
        z-index: 2;
      }
      @keyframes static-noise {
        0% { transform: translate(0, 0); }
        100% { transform: translate(-5%, -5%); }
      }
      #title-screen,
      #party-select,
      #game-container,
      #victory,
      #game-over,
      #mode-up-window {
        display: none;
        padding: 20px;
      }
      #battlefield {
        display: inline-block;
        border: 2px solid white;
        padding: 10px;
        margin-bottom: 10px;
      }
      .row {
        display: flex;
        justify-content: center;
      }
      .cell {
        width: 40px;
        height: 40px;
        text-align: center;
        font-size: 18px;
        border: 1px solid gray;
        line-height: 40px;
        transition: all 0.2s ease-in-out;
      }
      .active {
        background-color: darkblue;
        color: white;
      }
      .attack-mode {
        background-color: darkred;
        color: white;
      }
      .enemy {
        color: #ff5722;
        font-weight: bold;
      }
      .highlight {
        border: 2px solid yellow;
      }
      button {
        padding: 10px;
        margin: 5px;
        font-size: 18px;
      }
      #game-over {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.90);
        z-index: 999;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #game-over h1 {
        font-size: 3em;
        margin-bottom: 20px;
      }
      #game-over p {
        font-size: 1.5em;
      }
      #mode-up-window {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        color: white;
      }
      #mode-up-window h2 {
        margin-bottom: 20px;
        margin-top: 20px;
      }
      #mode-up-hero-display {
        margin: 10px;
        font-size: 1.2em;
      }
      #mode-up-instructions {
        margin-top: 10px;
      }
      .stat-up {
        color: #32cd32;
        font-weight: bold;
      }
      .dead-hero {
        color: #aaa;
        text-decoration: line-through;
      }
    </style>
  </head>
  <body>
    <!-- Title Screen -->
    <div id="title-screen">
      <div class="image-container">
        <div class="static-noise"></div>
      </div>
      <p>PRESS SPACE</p>
    </div>

    <!-- Party Selection Screen -->
    <div id="party-select">
      <h2>
        Select Your Party<br />
        (Use Left/Right Arrow keys to navigate and Spacebar to select/deselect.
        Choose exactly 3 heroes.)
      </h2>
      <div id="hero-display"></div>
      <p id="selection-info"></p>
    </div>

    <!-- Battle Screen -->
    <div id="game-container">
      <h1 id="level-title">Level Title</h1>
      <div id="battlefield"></div>
      <p id="status"></p>
      <div
        id="log"
        style="height:100px; overflow-y:auto; background-color:#111; padding:10px; border:1px solid white; text-align:left;"
      ></div>
      <p>
        Use Arrow Keys to Move | Press Spacebar to Attack, then choose attack direction.
      </p>
    </div>

    <!-- Victory Screen -->
    <div id="victory">
      <h1>Victory!</h1>
      <p>Congratulations! All levels have been completed!</p>
      <p>Press Spacebar to Restart</p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
      <h1>Game Over</h1>
      <p>All your heroes have been defeated.<br />Press Spacebar to Restart.</p>
    </div>

    <!-- Mode Up Window -->
    <div id="mode-up-window">
      <h2>Level Complete! Choose one living hero to power up everyone:</h2>
      <div id="mode-up-hero-display"></div>
      <p id="mode-up-instructions">
        Use Left/Right to select. Press Space to confirm.
      </p>
    </div>

    <audio id="background-music" src="DarkAnoid.mp3" loop></audio>

    <script type="module">
      import {
        fetchJoke,
        fetchBaconIpsum,
        fetchTarotCard,
        fetchNonseqFact,
        getGriotReaction,
        initializeGriot,
        recordInteraction,
      } from "./griot.js";
      import { BattleEngine } from "./battleEngine.js";
      import { heroes as allHeroes } from "./heroes.js";
      import { getLevel } from "./levels.js";

      let currentScreen = "title";
      let selectedHeroes = [];
      let heroIndex = 0;
      let party = [];
      // Initialize starting level number normally.
      let level = 1;
      let enemies = [];
      let battleEngine = null;
      let cheatActive = false;  // Flag to prevent repeated cheat activation

      // Cheat code detection variables.
      const cheatSequence = [
        "ArrowLeft",
        "ArrowLeft",
        "ArrowRight",
        "ArrowRight",
        "ArrowUp",
        "ArrowUp",
        "ArrowDown",
        "Space"
      ];
      let cheatBuffer = [];

      // For Mode Up selection:
      let modeUpIndex = 0;
      let livingHeroes = [];

      function showScreen(screen) {
        document.getElementById("title-screen").style.display = (screen === "title") ? "flex" : "none";
        document.getElementById("party-select").style.display = (screen === "party") ? "block" : "none";
        document.getElementById("game-container").style.display = (screen === "battle") ? "block" : "none";
        document.getElementById("victory").style.display = (screen === "victory") ? "block" : "none";
        document.getElementById("mode-up-window").style.display = (screen === "modeUp") ? "flex" : "none";
        currentScreen = screen;
      }

      async function updateHeroDisplay() {
        const hero = allHeroes[heroIndex];
        let display = `<p class="highlight">${hero.name} (${hero.symbol})</p>`;
        if (hero.joke) {
          const joke = await fetchJoke();
          display += `<p>${joke}</p>`;
        } else if (hero.meat) {
          const meatMsg = await fetchBaconIpsum();
          display += `<p>${meatMsg}</p>`;
        } else if (hero.tarot) {
          const tarot = await fetchTarotCard();
          display += `<p>${tarot}</p>`;
        } else if (hero.nonseq) {
          const fact = await fetchNonseqFact();
          display += `<p>${fact}</p>`;
        } else if (hero.reactsToHistory) {
          const reaction = await getGriotReaction();
          display += `<p>${reaction}</p>`;
        } else {
          display += `<p>Attack: ${hero.attack} | Range: ${hero.range} | Agility: ${hero.agility} | HP: ${hero.hp}`;
          if (hero.heal !== undefined) {
            display += ` | Heal: ${hero.heal}`;
          }
          display += `</p>`;
          display += `<p>${selectedHeroes.includes(heroIndex) ? "SELECTED" : "Press Spacebar to Select"}</p>`;
        }
        document.getElementById("hero-display").innerHTML = display;
        document.getElementById("selection-info").textContent = `Selected Heroes: ${selectedHeroes.length}/3`;
      }

      function selectHero() {
        if (selectedHeroes.includes(heroIndex)) {
          selectedHeroes = selectedHeroes.filter(i => i !== heroIndex);
        } else if (selectedHeroes.length < 3) {
          selectedHeroes.push(heroIndex);
        }
        updateHeroDisplay();
      }

      function startGame() {
        if (selectedHeroes.length !== 3) {
          alert("Select exactly 3 heroes!");
          return;
        }
        const backgroundMusic = document.getElementById("background-music");
        backgroundMusic.play().catch(() => {});
        party = selectedHeroes.map(i => Object.assign({}, allHeroes[i]));
        party.sort((a, b) => b.agility - a.agility);
        initializeBattle();
        showScreen("battle");
      }

      function getModeUpBuff(chosenHero) {
        const buffIncrement = level;
        if (chosenHero.name === "Knight") {
          return { attack: 1 * buffIncrement, hp: 2 * buffIncrement };
        } else if (chosenHero.name === "Archer") {
          return { range: 1 * buffIncrement };
        } else if (chosenHero.name === "Berserker") {
          return { attack: 3 * buffIncrement };
        } else if (chosenHero.name === "Rogue") {
          return { agility: 2 * buffIncrement };
        } else if (chosenHero.name === "Torcher") {
          return { burn: 1 * buffIncrement };
        } else if (chosenHero.name === "Slüjier") {
          return { sluj: 1 * buffIncrement };
        } else if (chosenHero.name === "Cleric") {
          return { heal: 2 * buffIncrement };
        } else if (chosenHero.heal !== undefined) {
          return { heal: 1 * buffIncrement };
        } else {
          return { ghis: 1 };
        }
      }

      function showModeUpWindow() {
        livingHeroes = party.filter(hero => hero.hp > 0);
        if (livingHeroes.length === 0) {
          setTimeout(initializeBattle, 500);
          return;
        }
        modeUpIndex = 0;
        showScreen("modeUp");
        updateModeUpHeroDisplay();
      }

      function updateModeUpHeroDisplay() {
        const hero = livingHeroes[modeUpIndex];
        const buff = getModeUpBuff(hero);
        const lines = [];
        lines.push(`<p class="highlight">${hero.name} (${hero.symbol})</p>`);
        lines.push(`<p>HP: ${hero.hp <= 0 ? `<span class="dead-hero">${hero.hp}</span>` : hero.hp} ${buff.hp ? `<span class="stat-up">+${buff.hp}</span>` : ""}</p>`);
        lines.push(`<p>Attack: ${hero.attack} ${buff.attack ? `<span class="stat-up">+${buff.attack}</span>` : ""}</p>`);
        lines.push(`<p>Range: ${hero.range} ${buff.range ? `<span class="stat-up">+${buff.range}</span>` : ""}</p>`);
        if (buff.agility) {
          lines.push(`<p class="stat-up">+${buff.agility} agility</p>`);
        }
        if (buff.burn) {
          lines.push(`<p class="stat-up">+${buff.burn} burn</p>`);
        }
        if (buff.sluj) {
          lines.push(`<p class="stat-up">+${buff.sluj} slüj</p>`);
        }
        if (buff.heal) {
          lines.push(`<p class="stat-up">+${buff.heal} heal</p>`);
        }
        if (buff.ghis) {
          lines.push(`<p>+<span class="stat-up">${buff.ghis} ghïs</span></p>`);
        }
        document.getElementById("mode-up-hero-display").innerHTML = lines.join("");
      }

      function applyModeUp(chosenHero) {
        const buff = getModeUpBuff(chosenHero);
        const messageParts = [];
        if (buff.hp) messageParts.push(`+${buff.hp} HP`);
        if (buff.attack) messageParts.push(`+${buff.attack} Attack`);
        if (buff.range) messageParts.push(`+${buff.range} Range`);
        if (buff.agility) messageParts.push(`+${buff.agility} Agility`);
        if (buff.burn) messageParts.push(`+${buff.burn} burn`);
        if (buff.sluj) messageParts.push(`+${buff.sluj} slüj`);
        if (buff.heal) messageParts.push(`+${buff.heal} Heal`);
        if (buff.ghis) messageParts.push(`+${buff.ghis} ghïs`);
        const message = messageParts.length > 0
          ? `${chosenHero.name} empowers the party with ${messageParts.join(", ")}!`
          : `${chosenHero.name} tries to mode up but nothing happens...`;

        party.forEach(h => {
          for (let stat in buff) {
            if (stat === "hp") {
              if (h.hp > 0) h.hp += buff[stat];
            } else {
              if (!Object.prototype.hasOwnProperty.call(h, stat)) {
                h[stat] = 0;
              }
              h[stat] += buff[stat];
            }
          }
        });
        logMessage(message);
        showScreen("battle");
        level++;
        setTimeout(initializeBattle, 2000);
      }

function initializeBattle() {
  const settings = getLevel(level);
  if (!settings) {
    // Only show victory if we're not in a special level sequence
    if (level < 99 || level > 101) {
      showScreen("victory");
      return;
    }
  }
  const { rows, cols, wallHP, title, enemies: levelEnemies } = settings;
  document.getElementById("level-title").textContent = title;
  enemies = levelEnemies;
  battleEngine = new BattleEngine(
    party,
    enemies,
    rows,
    cols,
    wallHP,
    logMessage,
    onLevelComplete,
    onGameOver
  );
  renderBattlefield();
}

function onLevelComplete() {
  // Handle normal progression (levels 1-4)
  if (level >= 1 && level <= 3) {
    logMessage(`Level ${level} complete!`);
    showModeUpWindow();
  }
  // Handle completion of normal game
  else if (level === 4) {
    logMessage("The normal path is complete!");
    showScreen("victory");
  }
  // Handle special levels progression
  else if (level === 99) {
    logMessage("The veil of introspection lifts...");
    level = 100;
    setTimeout(initializeBattle, 2000);
  }
  else if (level === 100) {
    logMessage("The echoes fade, revealing the final challenge...");
    level = 101;
    setTimeout(initializeBattle, 2000);
  }
  // Handle Gratt Prime (endless mode)
  else if (level === 101) {
    const currentWave = battleEngine.waveNumber || 0;
    if (battleEngine.wallHP <= 0) {
      logMessage("You've broken through! The eternal wall falls!");
      showScreen("victory");
    } else {
      logMessage(`Wave ${currentWave + 1} complete!`);
      setTimeout(initializeBattle, 2000);
    }
  }
}

      function onGameOver() {
        document.getElementById("game-over").style.display = "flex";
      }

      function renderBattlefield() {
        document.getElementById("battlefield").innerHTML = battleEngine.drawBattlefield();
        document.getElementById("status").textContent =
          `Wall HP: ${battleEngine.wallHP} | ${party[battleEngine.currentUnit].name}'s Turn (Moves Left: ${battleEngine.movePoints})`;
      }

      function logMessage(message) {
        const logDiv = document.getElementById("log");
        logDiv.innerHTML += `<p>${message}</p>`;
        logDiv.scrollTop = logDiv.scrollHeight;
      }

      async function recordAttack(message) {
        recordInteraction(message);
        const hero = party[battleEngine.currentUnit];
        if (hero.joke) {
          const joke = await fetchJoke();
          logMessage(joke);
        } else if (hero.meat) {
          const meatMsg = await fetchBaconIpsum();
          logMessage(meatMsg);
        } else if (hero.tarot) {
          const tarot = await fetchTarotCard();
          logMessage(tarot);
        } else if (hero.nonseq) {
          const fact = await fetchNonseqFact();
          logMessage(fact);
        } else if (hero.reactsToHistory) {
          const reaction = await getGriotReaction();
          logMessage(reaction);
        }
      }
function restartGame() {
    level = 1;
    selectedHeroes = [];
    party = [];
    heroIndex = 0;
    cheatActive = false; // Reset the cheat flag
    document.getElementById("log").innerHTML = "";
    document.getElementById("game-over").style.display = "none";
    showScreen("title");
}

      // Function to activate the cheat code branch (Level 99: The Hidden Arena)
      function activateCheat() {
        if (!cheatActive) {
          cheatActive = true; // Prevent activating multiple times
          console.log("Cheat code detected! Activating Level 99: The Hidden Arena!");
          level = 99;  // Set the level to 99
          initializeBattle(); // Re-initialize the battle with the new level
        }
      }

      // Global keydown listener for cheat code detection
      document.addEventListener("keydown", async (event) => {
        // Add key to cheat buffer.
        cheatBuffer.push(event.code);
        // Keep only the latest N key presses.
        if (cheatBuffer.length > cheatSequence.length) {
          cheatBuffer.shift();
        }
        // Check if the sequence matches.
        if (cheatBuffer.join() === cheatSequence.join()) {
          activateCheat();
          // Clear the buffer once the cheat code is activated.
          cheatBuffer = [];
          return;
        }
        
        // Handle screen-specific key actions.
        if (document.getElementById("game-over").style.display === "flex") {
          const action = keyActions["game-over"][event.code] || keyActions["game-over"][event.key];
          if (action) {
            event.preventDefault();
            await action();
          }
          return;
        }
        const actions = keyActions[currentScreen];
        const action = actions && (actions[event.code] || actions[event.key]);
        if (action) {
          event.preventDefault();
          await action();
        }
      });

      const keyActions = {
        title: {
          Space: () => {
            showScreen("party");
            updateHeroDisplay();
          }
        },
        party: {
          ArrowLeft: () => {
            heroIndex = (heroIndex - 1 + allHeroes.length) % allHeroes.length;
            updateHeroDisplay();
          },
          ArrowRight: () => {
            heroIndex = (heroIndex + 1) % allHeroes.length;
            updateHeroDisplay();
          },
          Space: () => {
            if (selectedHeroes.length < 3 || !selectedHeroes.includes(heroIndex)) {
              selectHero();
            } else {
              startGame();
            }
            updateHeroDisplay();
          }
        },
        battle: {
          Space: () => {
            battleEngine.awaitingAttackDirection = true;
            logMessage(`${party[battleEngine.currentUnit].name} is ready to attack! Choose a direction.`);
            renderBattlefield();
          },
          ArrowUp: async () => {
            if (battleEngine.awaitingAttackDirection) {
              await battleEngine.attackInDirection(0, -1, party[battleEngine.currentUnit], recordAttack);
            } else {
              battleEngine.moveUnit(0, -1);
            }
            renderBattlefield();
          },
          ArrowDown: async () => {
            if (battleEngine.awaitingAttackDirection) {
              await battleEngine.attackInDirection(0, 1, party[battleEngine.currentUnit], recordAttack);
            } else {
              battleEngine.moveUnit(0, 1);
            }
            renderBattlefield();
          },
          ArrowLeft: async () => {
            if (battleEngine.awaitingAttackDirection) {
              await battleEngine.attackInDirection(-1, 0, party[battleEngine.currentUnit], recordAttack);
            } else {
              battleEngine.moveUnit(-1, 0);
            }
            renderBattlefield();
          },
          ArrowRight: async () => {
            if (battleEngine.awaitingAttackDirection) {
              await battleEngine.attackInDirection(1, 0, party[battleEngine.currentUnit], recordAttack);
            } else {
              battleEngine.moveUnit(1, 0);
            }
            renderBattlefield();
          }
        },
        victory: {
          Space: () => restartGame()
        },
        "game-over": {
          Space: () => restartGame()
        },
        modeUp: {
          ArrowLeft: () => {
            if (livingHeroes.length > 0) {
              modeUpIndex = (modeUpIndex - 1 + livingHeroes.length) % livingHeroes.length;
              updateModeUpHeroDisplay();
            }
          },
          ArrowRight: () => {
            if (livingHeroes.length > 0) {
              modeUpIndex = (modeUpIndex + 1) % livingHeroes.length;
              updateModeUpHeroDisplay();
            }
          },
          Space: () => {
            if (livingHeroes.length > 0) {
              applyModeUp(livingHeroes[modeUpIndex]);
            }
          }
        }
      };

      initializeGriot("fantasy_narrative.txt").then(() => {
        showScreen("title");
      });
    </script>
  </body>
</html>
