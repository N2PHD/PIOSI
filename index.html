<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>PIOSI - Modular Game with Accurate Enemy Pathing</title>
    <!-- Load the extra light (200) version of the Sono font from Google Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Sono:wght@200&display=swap"
      rel="stylesheet"
    />
    <style>
      html {
        font-size: 14px;
      }
      body {
        font-family: 'Sono', monospace;
        font-size: 1rem;
        text-align: center;
        background-color: #222;
        color: white;
        margin: 0;
        padding: 0;
      }
      #title-screen {
        position: relative;
        height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        overflow: hidden;
      }
      #title-screen::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('IMG_0905.JPG') no-repeat center center;
        background-size: cover;
        filter: blur(20px);
        opacity: 0.7;
        z-index: -1;
      }
      .image-container {
        width: 80%;
        height: 80%;
        max-width: 80vh;
        max-height: 80vw;
        background: url('IMG_0905.JPG') no-repeat center center;
        background-size: contain;
        z-index: 1;
      }
      .image-container::before {
        content: '';
        position: absolute;
        top: -20%;
        left: -20%;
        width: 140%;
        height: 140%;
        background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAAAAAsNcNlwAAAAkUlEQVR42mNkgIH/j4wMDAwMDAY0wAGGfgYWFgYGBgYGNpgIMEAoggMDwMDAwMDAwMAAALsc9j1vXLaAAAAAAElFTkSuQmCC') repeat;
        opacity: 0.1;
        animation: static-noise 10s linear infinite;
        z-index: 2;
      }
      @keyframes static-noise {
        0% { transform: translate(0, 0); }
        100% { transform: translate(-5%, -5%); }
      }
      #title-screen,
      #party-select,
      #game-container,
      #victory,
      #game-over,
      #mode-up-window {
        display: none;
        padding: 20px;
      }
      #battlefield {
        display: inline-block;
        border: 2px solid white;
        padding: 10px;
        margin-bottom: 10px;
      }
      .row {
        display: flex;
        justify-content: center;
      }
      .cell {
        width: 40px;
        height: 40px;
        text-align: center;
        font-size: 18px;
        border: 1px solid gray;
        line-height: 40px;
        transition: all 0.2s ease-in-out;
      }
      .active {
        background-color: darkblue;
        color: white;
      }
      .attack-mode {
        background-color: darkred;
        color: white;
      }
      .enemy {
        color: #ff5722;
        font-weight: bold;
      }
      .highlight {
        border: 2px solid yellow;
      }
      button {
        padding: 10px;
        margin: 5px;
        font-size: 18px;
      }
      #game-over {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.90);
        z-index: 999;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }
      #game-over h1 {
        font-size: 3em;
        margin-bottom: 20px;
      }
      #game-over p {
        font-size: 1.5em;
      }
      #mode-up-window {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        color: white;
      }
      #mode-up-window h2 {
        margin-bottom: 20px;
        margin-top: 20px;
      }
      #mode-up-hero-display {
        margin: 10px;
        font-size: 1.2em;
      }
      #mode-up-instructions {
        margin-top: 10px;
      }
      .stat-up {
        color: #32cd32;
        font-weight: bold;
      }
      .dead-hero {
        color: #aaa;
        text-decoration: line-through;
      }
    </style>
  </head>
  <body>
    <!-- Title Screen -->
    <div id="title-screen">
      <div class="image-container">
        <div class="static-noise"></div>
      </div>
      <p>PRESS SPACE</p>
    </div>

    <!-- Party Selection Screen -->
    <div id="party-select">
      <h2>
        Select Your Party<br />
        (Use Left/Right Arrow keys to navigate and Spacebar to select/deselect.
        Choose at least 3 heroes.)
      </h2>
      <div id="hero-display"></div>
      <p id="selection-info"></p>
    </div>

    <!-- Battle Screen -->
    <div id="game-container">
      <h1 id="level-title">Level Title</h1>
      <div id="battlefield"></div>
      <p id="status"></p>
      <div
        id="log"
        style="height:100px; overflow-y:auto; background-color:#111; padding:10px; border:1px solid white; text-align:left;"
      ></div>
      <p>
        Use Arrow Keys to Move | Press Spacebar to Attack, then choose attack direction.
      </p>
    </div>

    <!-- Victory Screen -->
    <div id="victory">
      <h1>Victory!</h1>
      <p>Congratulations! All levels have been completed!</p>
      <p>Press Spacebar to Restart</p>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over">
      <h1>Game Over</h1>
      <p>All your heroes have been defeated.<br />Press Spacebar to Restart.</p>
    </div>

    <!-- Mode Up Window -->
    <div id="mode-up-window">
      <h2>Level Complete! Choose one living hero to power up everyone:</h2>
      <div id="mode-up-hero-display"></div>
      <p id="mode-up-instructions">
        Use Left/Right to select. Press Space to confirm.
      </p>
    </div>

    <audio id="background-music" src="DarkAnoid.mp3" loop></audio>

    <script type="module">
      import {
        fetchJoke,
        fetchBaconIpsum,
        fetchTarotCard,
        fetchNonseqFact,
        fetchShrinkAdvice,
        getGriotReaction,
        initializeGriot,
        recordInteraction,
      } from "./griot.js";
      import { BattleEngine } from "./battleEngine.js";
      import { heroes as allHeroes } from "./heroes.js";
      import { getLevel } from "./levels.js";

      let currentScreen = "title";
      let selectedHeroes = [];
      let heroIndex = 0;
      let party = [];
      let level = 1;
      let enemies = [];
      let battleEngine = null;
      let cheatActive = false;

      const cheatSequence = [
        "ArrowLeft",
        "ArrowLeft",
        "ArrowRight",
        "ArrowRight",
        "ArrowUp",
        "ArrowUp",
        "ArrowDown",
        "Space"
      ];
      let cheatBuffer = [];

      let modeUpIndex = 0;
      let livingHeroes = [];

      function showScreen(screen) {
        document.getElementById("title-screen").style.display = (screen === "title") ? "flex" : "none";
        document.getElementById("party-select").style.display = (screen === "party") ? "block" : "none";
        document.getElementById("game-container").style.display = (screen === "battle") ? "block" : "none";
        document.getElementById("victory").style.display = (screen === "victory") ? "block" : "none";
        document.getElementById("mode-up-window").style.display = (screen === "modeUp") ? "flex" : "none";
        currentScreen = screen;
      }

      async function updateHeroDisplay() {
        const hero = allHeroes[heroIndex];
        let display = `<p class="highlight">${hero.name} (${hero.symbol})</p>`;
        if (hero.joke) {
          const joke = await fetchJoke();
          display += `<p>${joke}</p>`;
        } else if (hero.meat) {
          const meatMsg = await fetchBaconIpsum();
          display += `<p>${meatMsg}</p>`;
        } else if (hero.tarot) {
          const tarot = await fetchTarotCard();
          display += `<p>${tarot}</p>`;
        } else if (hero.nonseq) {
          const fact = await fetchNonseqFact();
          display += `<p>${fact}</p>`;
        } else if (hero.shrink) {
          const advice = await fetchShrinkAdvice();
          display += `<p>Advice: ${advice}</p>`;
        } else if (hero.reactsToHistory) {
          const reaction = await getGriotReaction();
          display += `<p>${reaction}</p>`;
        } else {
          display += `<p>Attack: ${hero.attack} | Range: ${hero.range} | Agility: ${hero.agility} | HP: ${hero.hp}`;
          if (hero.heal !== undefined) {
            display += ` | Heal: ${hero.heal}`;
          }
          display += `</p>`;
          display += `<p>${selectedHeroes.includes(heroIndex) ? "SELECTED" : "Press Spacebar to Select"}</p>`;
        }
        document.getElementById("hero-display").innerHTML = display;
        document.getElementById("selection-info").textContent = `Selected Heroes: ${selectedHeroes.length} (Choose at least 3)`;
      }

      // Updated startGame to allow 3 or more heroes to be selected. If more than 3 are chosen, only the first 3 are used.
      function startGame() {
        if (selectedHeroes.length < 3) {
          alert("Select at least 3 heroes!");
          return;
        }
        const backgroundMusic = document.getElementById("background-music");
        backgroundMusic.play().catch(() => {});
        party = selectedHeroes.slice(0, 3).map(i => Object.assign({}, allHeroes[i]));
        party.sort((a, b) => b.agility - a.agility);
        initializeBattle();
        showScreen("battle");
      }

      function selectHero() {
        if (selectedHeroes.includes(heroIndex)) {
          selectedHeroes = selectedHeroes.filter(i => i !== heroIndex);
        } else {
          selectedHeroes.push(heroIndex);
        }
        updateHeroDisplay();
      }

      function getModeUpBuff(chosenHero) {
        const buffIncrement = level;
        if (chosenHero.name === "Knight") {
          return { attack: 1 * buffIncrement, hp: 2 * buffIncrement };
        } else if (chosenHero.name === "Archer") {
          return { range: 1 * buffIncrement };
        } else if (chosenHero.name === "Berserker") {
          return { attack: 3 * buffIncrement };
        } else if (chosenHero.name === "Rogue") {
          return { agility: 2 * buffIncrement };
        } else if (chosenHero.name === "Torcher") {
          return { burn: 1 * buffIncrement };
        } else if (chosenHero.name === "Slüjier") {
          return { sluj: 1 * buffIncrement };
        } else if (chosenHero.name === "Cleric") {
          return { heal: 2 * buffIncrement };
        } else if (chosenHero.heal !== undefined) {
          return { heal: 1 * buffIncrement };
        } else {
          return { ghis: 1 };
        }
      }

      function showModeUpWindow() {
        livingHeroes = party.filter(hero => hero.hp > 0);
        if (livingHeroes.length === 0) {
          setTimeout(initializeBattle, 500);
          return;
        }
        modeUpIndex = 0;
        showScreen("modeUp");
        updateModeUpHeroDisplay();
      }

      function updateModeUpHeroDisplay() {
        const hero = livingHeroes[modeUpIndex];
        const buff = getModeUpBuff(hero);
        const lines = [];
        lines.push(`<p class="highlight">${hero.name} (${hero.symbol})</p>`);
        lines.push(`<p>HP: ${hero.hp <= 0 ? `<span class="dead-hero">${hero.hp}</span>` : hero.hp} ${buff.hp ? `<span class="stat-up">+${buff.hp}</span>` : ""}</p>`);
        lines.push(`<p>Attack: ${hero.attack} ${buff.attack ? `<span class="stat-up">+${buff.attack}</span>` : ""}</p>`);
        lines.push(`<p>Range: ${hero.range} ${buff.range ? `<span class="stat-up">+${buff.range}</span>` : ""}</p>`);
        if (buff.agility) {
          lines.push(`<p class="stat-up">+${buff.agility} agility</p>`);
        }
        if (buff.burn) {
          lines.push(`<p class="stat-up">+${buff.burn} burn</p>`);
        }
        if (buff.sluj) {
          lines.push(`<p class="stat-up">+${buff.sluj} slüj</p>`);
        }
        if (buff.heal) {
          lines.push(`<p class="stat-up">+${buff.heal} heal</p>`);
        }
        if (buff.ghis) {
          lines.push(`<p>+<span class="stat-up">${buff.ghis} ghïs</span></p>`);
        }
        document.getElementById("mode-up-hero-display").innerHTML = lines.join("");
      }

      function applyModeUp(chosenHero) {
        const buff = getModeUpBuff(chosenHero);
        const messageParts = [];
        if (buff.hp) messageParts.push(`+${buff.hp} HP`);
        if (buff.attack) messageParts.push(`+${buff.attack} Attack`);
        if (buff.range) messageParts.push(`+${buff.range} Range`);
        if (buff.agility) messageParts.push(`+${buff.agility} Agility`);
        if (buff.burn) messageParts.push(`+${buff.burn} burn`);
        if (buff.sluj) messageParts.push(`+${buff.sluj} slüj`);
        if (buff.heal) messageParts.push(`+${buff.heal} Heal`);
        if (buff.ghis) messageParts.push(`+${buff.ghis} ghïs`);
        const message = messageParts.length > 0
          ? `${chosenHero.name} empowers the party with ${messageParts.join(", ")}!`
          : `${chosenHero.name} tries to mode up but nothing happens...`;

        party.forEach(h => {
          for (let stat in buff) {
            if (stat === "hp") {
              if (h.hp > 0) h.hp += buff[stat];
            } else {
              if (!Object.prototype.hasOwnProperty.call(h, stat)) {
                h[stat] = 0;
              }
              h[stat] += buff[stat];
            }
          }
        });
        logMessage(message);
        showScreen("battle");
        level++;
        setTimeout(initializeBattle, 2000);
      }

      function initializeBattle() {
        const settings = getLevel(level);
        if (!settings) {
          if (level < 99 || level > 101) {
            showScreen("victory");
            return;
          }
        }
        const { rows, cols, wallHP, title, enemies: levelEnemies } = settings;
        document.getElementById("level-title").textContent = title;
        enemies = levelEnemies;
        battleEngine = new BattleEngine(
          party,
          enemies,
          rows,
          cols,
          wallHP,
          logMessage,
          onLevelComplete,
          onGameOver
        );
        renderBattlefield();
      }

      function onLevelComplete() {
        if (level >= 1 && level <= 3) {
          logMessage(`Level ${level} complete!`);
          showModeUpWindow();
        } else if (level === 4) {
          logMessage("The normal path is complete!");
          showScreen("victory");
        } else if (level === 99) {
          logMessage("The veil of introspection lifts...");
          level = 100;
          setTimeout(initializeBattle, 2000);
        } else if (level === 100) {
          logMessage("The echoes fade, revealing the final challenge...");
          level = 101;
          setTimeout(initializeBattle, 2000);
        } else if (level === 101) {
          const currentWave = battleEngine.waveNumber || 0;
          if (battleEngine.wallHP <= 0) {
            logMessage("You've broken through! The eternal wall falls!");
            showScreen("victory");
          } else {
            logMessage(`Wave ${currentWave + 1} complete!`);
            setTimeout(initializeBattle, 2000);
          }
        }
      }

      function onGameOver() {
        document.getElementById("game-over").style.display = "flex";
      }

      function renderBattlefield() {
        document.getElementById("battlefield").innerHTML = battleEngine.drawBattlefield();
        document.getElementById("status").textContent =
          `Wall HP: ${battleEngine.wallHP} | ${party[battleEngine.currentUnit].name}'s Turn (Moves Left: ${battleEngine.movePoints})`;
      }

      function logMessage(message) {
        const logElement = document.getElementById("log");
        logElement.innerHTML += `<p>${message}</p>`;
        logElement.scrollTop = logElement.scrollHeight;
      }

      document.addEventListener("keydown", async (event) => {
        cheatBuffer.push(event.code);
        if (cheatBuffer.length > cheatSequence.length) {
          cheatBuffer.shift();
        }
        if (cheatBuffer.join() === cheatSequence.join()) {
          if (!cheatActive) {
            cheatActive = true;
            console.log("Cheat code detected! Activating Level 99: The Hidden Arena!");
            level = 99;
            initializeBattle();
          }
          cheatBuffer = [];
          return;
        }

        if (currentScreen === "title" && event.code === "Space") {
          showScreen("party");
          updateHeroDisplay();
        } else if (currentScreen === "party") {
          if (event.code === "ArrowRight") {
            heroIndex = (heroIndex + 1) % allHeroes.length;
            updateHeroDisplay();
          } else if (event.code === "ArrowLeft") {
            heroIndex = (heroIndex - 1 + allHeroes.length) % allHeroes.length;
            updateHeroDisplay();
          } else if (event.code === "Space") {
            selectHero();
          } else if (event.code === "Enter") {
            startGame();
          }
        } else if (currentScreen === "battle") {
          // Handle battle screen key actions here, such as movement or attack.
        } else if (currentScreen === "modeUp") {
          if (event.code === "ArrowRight") {
            modeUpIndex = (modeUpIndex + 1) % livingHeroes.length;
            updateModeUpHeroDisplay();
          } else if (event.code === "ArrowLeft") {
            modeUpIndex = (modeUpIndex - 1 + livingHeroes.length) % livingHeroes.length;
            updateModeUpHeroDisplay();
          } else if (event.code === "Space") {
            if (livingHeroes.length > 0) {
              applyModeUp(livingHeroes[modeUpIndex]);
            }
          }
        } else if (currentScreen === "victory" || currentScreen === "game-over") {
          if (event.code === "Space") {
            level = 1;
            selectedHeroes = [];
            party = [];
            heroIndex = 0;
            cheatActive = false;
            document.getElementById("log").innerHTML = "";
            document.getElementById("game-over").style.display = "none";
            showScreen("title");
          }
        }
      });

      initializeGriot("fantasy_narrative.txt").then(() => {
        showScreen("title");
      });
    </script>
  </body>
</html>
